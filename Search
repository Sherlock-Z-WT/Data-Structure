//查找
//顺序查找
//从头到尾查找
typedef struct{
    ElemType *Elem;
    int Tablelen;
}SSTable;
int search-seq(SSTable ST,ELemType key){
    int i;
    for(i=0;i<ST.Tablelen&&ST.Elem[i]!=key;i++)
        return i==ST.Tablelen? -1:i;
}
//查找效率ASL成功=（n+1）/2 ASL失败=n+1

//二分查找
//仅仅适用于有序的顺序表
typedef struct{
    ElemType *Elem;
    int Tablelen;
}SSTable;
int Binary-search(SSTable L,Elemtype key){
    int low=0,high=L.Tablelen-1;
    while(low<=high){
        int mid = (low+high)/2;
        if(L.elem[mid]=key)
            return mid;
        else if(L.Elem[mid]>key)
            high = mid -1;
        else
            low = mid + 1;
    }
    return -1;
}
//二分查找判定树
//对于任何一个结点，右子树结点数-左子树结点数=0或者1
//只有最下面一层不满，判定树结点关键字：左<中<右
//树高h=log2（n+1），时间复杂度O（log2n）

//分块查找
//块内无序，块间有序
typedef struct{
    ElemType max;
    int low,high;
}Index;
//在表中确定待查记录所属分块，在块内顺序查找
//索引表中不含目标关键字，则最终停在low>high，在low分块查找

//二叉查找树 BST
//左子树结点值<根节点<右子树结点值
typedef struct BSTNode{
    int key;
    struct BSTNode *lchild,*rchild;
}BSTNode,*BSTree;
BSTNOde *BST-search(BSTree T,int key){
    while(T!=NULL&&key!=T->key)
        if(key<T->key) T = T->lchild;
        else T = T->rchild;
    return T;
}
//插入
int BST-insert(BSTree T,int k){
    if(T==NULL)
        T=(BSTree)malloc(sizeof(BSTNode))
        T->key = k;
        T->lchild=T->rchild=NULL;
        return 1;
    else if(k=T->key) return 0;
    else if(k<T->key) return BST-insert(T->lchild,k)
    else return BST-insert(T->rchild,k)
}
//构造
void create-BST(BSTree &T,int str[],int n){
    T=NULL;
    int i =0;
    while(i<n)
        BST-insert(T,str[i]);
        i++
}

//平衡二叉树
//任意一点的左右子树高度差不大于1
//结点平衡因子：左子树高-右子树高

//红黑树 RBT
//是一种二叉排序树（左<根<右）
//1.每一个结点只能是红或者黑 2.根节点，叶子结点都是黑 3.不存在两个相邻的红结点 4.任意一个结点到空叶结点路径上的黑结点数目相同
struct RBnode{
    int key;
    RBnode *parent;
    RBnode *lchild;
    RBnode *rchild;
    int color;
}
//左根右，根叶黑，不红红，黑路同
//从根节点到叶结点的最长路径不大于最短路径的2倍 

//哈希表
// 可以根据数据元素的关键字算出它在哈希表中的存储地址
// 冲突：插入一个数据元素，在该地址已经存储了其他元素
// 同义词：不同关键字通过哈希函数映射到同一个地址
// 对于哈希函数H（key）=key%13，1和14是同义词
// 哈希函数的构造
// 应该尽可能的减少冲突
// 定义域涵盖所有可能出现的关键字
// 值域不超出哈希表的地址范围
// 除留余数法
// 哈希表表长为m，取一个不大于但是最接近或者等于m的质数p
// 表长13，key%13；表长15，key%13
// 可以使得分布更均匀，减少冲突
// 处理冲突
// 拉链法：将同义词放在一个链表中
// 开放定址法：发生冲突就给新元素找另一个空闲位置

