//队列Queue
//只可以一端插入，另一端删除的线性表
//队尾：插入一端  队头：删除一端
//先进先出 first in first out FIFO
//入队：x成为新的队尾  出队：删除队头元素
#define MaxSize 10;
typedef struct{
    ElemType data[MaxSize];
    int front,rear;//队头队尾
}SqQueue;
//初始化队列
void InitQueue(SqQueue &Q){
    Q.rear = Q.front = 0;//队头尾指针指向0
}

//入队
bool EnQueue(SqQueue &Q,ElemType x){
    Q.data[Q.rear] = x;//x插入队尾
    Q.rear = Q.rear +1;//队尾指针后移
    return true;
}

//出队
bool DeQueue(SqQueue &Q,ElemType &x){
    if(Q.rear == Q.front)
        return false;//队空
    x = Q.data[Q.front];
    Q.front = (Q.front + 1)%MaxSize；
    return true;
}

//队列已满：队尾指针的下一位置是队头(Q.rear+1)%MaxSize==Q.front
//队空：Q.rear == Q.front
//队列元素个数：（rear+MaxSize-front)%MaxSize
//%是让队列成为一个循环队列


//链式队列
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
}LinkNode;
typedef struct{
    LinkNode *front,*rear;//队头队尾指针
}LinkQueue;

//初始化
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
}LinkNode;
typedef struct {
    LinkNode *front,*rear;
}LinkQueue;
void InitQueue(LinkQueue &Q){
    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));//front，rear都指向头结点
    Q.front->next = NULL;
}
if(Q.front == Q.rear)//队列为空

//入队
void EnQueue(LinkQueue &Q,ElemType x){
    LinkNode*s = (LinkNode*)malloc(sizeof(LinkNode));
    s->data = x;
    s->next = NULL;
    Q.rear->next = s;
    Q.rear = s;
}

//出队（带头结点）
bool DeQueue(LinkQueue &Q,ElemType &x){
    if(Q.front == Q.rear)
        return false;//空队
    LinkNode *p = Q.front->next;
    x = p->data;
    Q.front->next = p->next;
    if(Q.rear == p)
        Q.rear = Q.front;
    free(p);
    return true;
}

//出队（不带头结点）
bool DeQueue(LinkQueue &Q,ElemType &x){
    if(Q.front == NULL)
        return false;
    LinkNode *p = Q.front;
    x = p->data;
    Q.front = p->next;
    if(Q.rear == p){
        Q.front = NULL;
        Q.rear = NULL;
    }
    free(p);
    return true;
}
//有无头结点区别就是定义p是Q.front还是Q.front->next
//链队列一般不会满，除非内存不足