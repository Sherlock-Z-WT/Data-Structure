// 稳定性：关键字相同的元素在排列后相对位置不变
// 插入排序
// 每次将一个待排序的元素按照大小插到前面已经排好序的子序列中
void InsertSort(int A[],int n){
    int i,j,temp;
    for(i=1;i<n;i++)
        if(A[i]<A[i-1])
            temp = A[i];
            for(j=i-1;j>=0&&A[j]>temp;j--)
                A[j+1] = A[j];//大于temp的元素后移
            A[j+1] = temp;//复制到插入位置
}
//或者带一个哨兵结点
void Insert Sort(int A[],int n){
    int i,j;
    for(i=2;i<n;i++)
        if(A[i]<A[i-1])
            A[0]=A[i];
            for(j=i-1;A[j]>a[0];j--)
                A[j+1] = A[j]
            A[j+1] = A[0];
}
//空间复杂度O（1），时间复杂度O（n2）
//优化----折半插入排序
void Insert Sort(int A[],int n){
    int i,j,high,low,mid;
    for(i=2;i<n;i++)
        if(A[i]<A[i-1])
            A[0]=A[i];
            low = 1;high = i-1;
            while(low<=high)
                mid = (high+low)/2;
                if(A[mid]>A[0])
                    high=mid-1;
                else
                    low=mid+1;
            for(j=i-1;j>=high+1;j--)
                A[j+1]=A[j];
            A[high+1]=A[0]
}
//时间复杂度O（n2）
