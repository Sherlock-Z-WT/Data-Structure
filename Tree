//树
//一个根节点，叶子结点没有后继结点，分支结点有
//任一结点仅有一个前驱结点，除了根结点
//0个结点为空树，路径单向，从上往下
//结点的度：有几个分支
//树的度：结点度的最大值
//有序树：各子树左到右是无次序的
//森林：n个不相交的树的集合

//二叉树
//一个根节点，2个互不相交的左右子树，有序
//满二叉树：所有的都满了，只有最后一层有叶子结点，不存在度为1的结点
//完全二叉树：编号大的几个没有，只有最后两层有叶子结点，最多有一个度为1的结点
//i<=n/2为分支结点，i>n/2为叶子结点
//如果只有一个孩子，那一定是左孩子
//二叉排序树：左子树所有结点小于根节点，右子树所有结点大于根节点
//平衡二叉树：任一个结点左右子树深度差不超过1，能有更高的搜索效率
//二叉树的叶子结点比二分支结点多一个
//完全二叉树最多只有一个度为1的结点

//顺序存储
#define Maxsize 100
struct Treenode{
    ElemType value;
    bool isEmpty;
};
Treenode t[Maxsize]
//i的左孩子2i，右孩子2i+1，父节点i/2

//链式存储
typedef struct BitNode{
    ElemType data;
    struct BitNode *lchild,*rchild;
}BitNode,*BiTree;
//定义根
BiTree root = NULL;
root = (BiTree)malloc(sizeof(BitNode));
root->data = {1};
root->lchild = NULL;
root->rchild = NULL;
//插入新结点
BitNode*p = (BitNode*)malloc(sizeof(BitNode));
p->data = {2};
p->lchild = NULL;
p->rchild = NULL;
root->lchild = p;

//遍历
//先序：根左右；中序：左根右；后序：左右根
//先序preorder
typedef struct BitNode{
    EleType data;
    struct BitNode *lchild,*rchild;
}BitNode,*Bitree;
void preorder(Bitree T){
    if(T!= NULL)
        visit(T);
        preorder(T->lchild);
        preorder(T->rchild);
}
//中序inorder
void inorder(Bitree T){
    if(T!=NULL)
        inorder(T->lchild);
        visit(T);
        inorder(T->rchild);
}
//后序postorder
void postorder(Bitree T){
    postorder(T->lchild);
    postorder(T->rchild);
    visit(T);
}
//应用：求树的深度
int depth(Bitree T){
    if(T!=NULL){
        int l = depth(lchild);
        int r = depth(rchild);
        return l>r?l+1:r+1;
    }else{
        return 0;
    }
}
//层序遍历二叉树
//1.初始一个队列2.根结点入队3.非空则队头出列，再将该结点左右孩子插入
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

// 定义队列节点结构（用于存储二叉树节点指针）
typedef struct QueueNode {
    TreeNode* data;
    struct QueueNode* next;
} QueueNode;

// 定义队列结构
typedef struct {
    QueueNode* front; // 队头指针
    QueueNode* rear;  // 队尾指针
} Queue;

// 初始化队列
void initQueue(Queue* q) {
    q->front = q->rear = NULL;
}

// 检查队列是否为空
int isQueueEmpty(Queue* q) {
    return q->front == NULL;
}

// 入队操作
void enqueue(Queue* q, TreeNode* data) {
    QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
    if (!newNode) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    newNode->data = data;
    newNode->next = NULL;
    
    if (isQueueEmpty(q)) {
        q->front = q->rear = newNode;
    } else {
        q->rear->next = newNode;
        q->rear = newNode;
    }
}

// 出队操作
TreeNode* dequeue(Queue* q) {
    if (isQueueEmpty(q)) {
        fprintf(stderr, "Queue is empty\n");
        return NULL;
    }
    QueueNode* temp = q->front;
    TreeNode* data = temp->data;
    q->front = q->front->next;
    
    if (q->front == NULL) {
        q->rear = NULL;
    }
    
    free(temp);
    return data;
}

// 层序遍历二叉树
void levelOrderTraversal(TreeNode* root) {
    if (root == NULL) return;
    
    Queue q;
    initQueue(&q);
    enqueue(&q, root); // 根节点入队
    
    while (!isQueueEmpty(&q)) {
        TreeNode* current = dequeue(&q); // 队头出队
        printf("%d ", current->val);     // 访问节点
        
        // 将左孩子入队
        if (current->left != NULL) {
            enqueue(&q, current->left);
        }
        
        // 将右孩子入队
        if (current->right != NULL) {
            enqueue(&q, current->right);
        }
    }
}

// 创建新节点
TreeNode* createNode(int val) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    if (!newNode) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    newNode->val = val;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// 主函数示例
int main() {
    // 构建示例二叉树: 
    //       1
    //      / \
    //     2   3
    //    / \
    //   4   5
    TreeNode* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    root->left->left = createNode(4);
    root->left->right = createNode(5);
    
    printf("层序遍历结果: ");
    levelOrderTraversal(root); // 输出: 1 2 3 4 5
    
    // 释放内存（实际应用中需递归释放所有节点）
    free(root->left->left);
    free(root->left->right);
    free(root->left);
    free(root->right);
    free(root);
    
    return 0;
}
