//图
//图G由顶点集V和边集E组成，G=（V，E）
//V：顶点的个数，图G的阶
//E：边的条数
//顶点数不能为0，边的数量可以为0
//无向边（边），有向边（弧）
//对于无向图，顶点的度：依附于该顶点的边的条数TD（V），所有的TD和为2E
//对于有向图：入度：以V为终点的有向边的数目ID（V）  出度：以V为起点的有向边的数目OD（V）
//顶点的度：TD（V）= ID（V）+OD（V） ID的和=OD的合=弧的条数

//路径：点到点的路
//回路：第一个和最后一个顶点相同的路
//路径长度：边数
//点到点的距离：最短的路径，如果没有就是无穷
//有n个结点的无向图G，如果是连通图，最少n-1条边
//有向图，若果是强连通图，最少n条边

//子图
//v1是v的子集，e1是e的子集，G（v1，e1）是G的子图
//连通分量：无向图中极大连通子图
//强连通分量：有向图中极大强连通子图

//无向完全图：任意两个点都存在边，n个顶点，（n2-n）/2条边
//有向完全图：任意两点都有相反方向的两条弧 n2-n条边

/////////图的存储
//邻接矩阵法
//0表示不邻接，1表示邻接
#define max 100
typedef struct{
    char vex[max];
    int edge[max][max];
    int vexnum,arcnum;
}MGraph;
//第i个结点的度=第i行非零元素的个数
//i出度=第i行的非0个数，i入度=第i列的非0个数

////邻接表法
//类似于树的孩子表示法，一边存数据，一边存一条边
typedef struct VNode{
    vertexType data;
    ArcNode *first;
}VNode,ADjlist[max]
typedef struct ArcNode{
    int sdjvex;
    struct ArcNode *next;
}ArcNode;11

//基本操作
ADjlist(G,X,Y)//G是否存在边（x，y）
neighbors(G,X)//与X邻接的边
InsertVertex(G,X)//插入X
DeleteVertex(G,X)//删除X
AddEdge(G,X,Y)//添加一条边
FirstNeighbor(G,X)//x的第一个邻接点，返回顶点号，没有就返回-1
Next Neighbor(G,X,Y)//除了Y之外X的下一个邻接点

///////////图的遍历
//BFS--广度优先遍历
bool visited[max]
void BFSTrave (Graph G){
    for(i=0;i<G.vexnum;i++)
        visited[i]=false;
    InitQueue(Q);
    for(i=0;i<G.vexnum;i++)
        if(!visited[i])
            BFS(G,i)
}
void BFS(Graph G,int v){
    visit(v);
    visited[i]=true;
    Enqueue(Q,v);
    while(!isempty(Q)){
        Dequeue(Q,v);
        for(int w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v))
            if(!visited[w]){
                visited(w);
                visited(w)=true;
                Enqueue(Q,w);
            }
    }
}

//广度优先生成树
//广度优先生成树由广度优先遍历过程确定，但是邻接表的表示方式不唯一，因此广度优先生成树也唯一
//对非连通图的广度优先遍历，可得广度优先森林

//深度优先遍历DFS
bool visited[max]
void DFSTraverse(Graph G){
    for(v=0;v<G.vexnum;++v){
        visited[v]=false;
    }
    for(v=0;v<G.vexnum;++v){
        if(!visited[v])
            DFS(G,v)
    }
}
void DFS(Graph G,int v){
    visit(v);
    visited[v]=true;
    for(int w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
        if(!visited[w])
            DFS(G,w)
}

//最小生成树
//Prim算法
//从某顶点开始构建，每次将权最小的新顶点纳入生成树，直到完成
//Kruskal算法
//每次选择一条权最小的边，让这两个顶点相通，直到所有的都相通（已经连通的不选）

//最短路径问题-BFS
//单源最短路径
bool visited[max]
void BFS-min(Graph G,int v)
    for(i=0;i<G.vexnum;++i)
        d[i]=∞;
        path[i]=-1;
    d[v]=0;
    visited[v]=true;
    Enqueue(Q,v)
    while(!isEmpty(Q)){
        Dequeue(Q,v)
        for(int w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
            if(!visited[w])
                d[w]=d[v]+1
                path[w]=v
                visited[w]=true;
                Enqueue(Q,w)
    }
//d[]表示单源到这个点的距离，一开始都是无穷
//path[]表示这一点的前驱，是从哪来的

//最短路径Dijkstra
//带权图
final[]//表示标记顶点是否找到最短路径，是就true，否就false
dist[]//表示最短的路径长度
path[]//表示路径上的前驱

//各个顶点间最短路径问题--Floyd算法
//初始：不允许中转，最短路径是？
//#0：有V0中转最短路径是？
//#1:有v0，v1中转，最短路径是多少？
//#n-1：有v0...Vn-1中转，最短路径是？
A//目前各个顶点间最短路径长度
path//两个顶点间的中转点

for(int k=0;k<n;k++){
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            if(A[i][j]>A[i][k]+A[k][j]){
                A[i][j]=A[i][k]+A[k][j]
                path[i][j]=k;//中转点
            }
        }
    }
}
